Chapter 1

==

You can compile and run your code on most machines using this trick:

gcc zork.c -o zork && ./zork

&& here means “and then if it’s successful, do this…”

This command will run the new program only if it compiles successfully. If there’s a problem with the compile, it will skip running the program and simply display the errors on the screen.

==

****************************
Chapter 2
****************************
a pointer is just the address of a piece of data in memory

a pointer variable is a variable that stores a memory address




****************************
Chapter 4
****************************
To compile c files to object code witout linking them:

gcc -c *.c


To link all object files together:

gcc *.o -o launch



You can compile your applications really quickly in gcc, as long as 
you keep track of  which files have changed. That’s a tricky thing to 
do, but it’s also pretty straightforward to automate. Imagine you have 
a file that is generated from some other file. Let’s say it’s an object 
file that is compiled from a source file:

thruster.c    --->   thruster.o

How do you tell if  the thruster.o file needs to be recompiled? You just 
look at the timestamps of  the two files. If  the thruster.o file is older 
than the thruster.c file, then the thruster.o file needs to be recreated. 
Otherwise, it’s up to date.

That’s a pretty simple rule. And if  you have a simple rule for 
something, then don’t think about it—automate it…


make is a tool that can run the compile command for you. The 
make tool will check the timestamps of  the source files and the 
generated files, and then it will only recompile the files if  things have 
gotten out of  date. 


Every file that make compiles is called a target. Strictly speaking, 
make isn’t limited to compiling files. A target is any file that is 
generated from some other files. So a target might be a zip archive 
that is generated from the set of  files that need to be compressed.


For every target, make needs to be told two things:

* The dependencies.
Which files the target is going to be generated from.


* The recipe.
The set of  instructions it needs to run to generate the file.


Together, the dependencies and the recipe form a rule. A rule tells 
make all it needs to know to create the target file. 


==


****************************
Chapter 6
****************************
valgrind can monitor the pieces of  data that are allocated 
space on the heap. It works by creating its own fake version 
of  malloc(). When your program wants to allocate some 
heap memory, valgrind will intercept your calls to malloc() 
and free() and run its own versions of  those functions. The 
valgrind version of  malloc() will take note of  which piece of  
code is calling it and which piece of  memory it allocated. When your 
program ends, valgrind will report back on any data that was left 
on the heap and tell you where in your code the data was created.

--

To be able to use valgrind you need to include debug information in your executable
You do so by using the -g switch

gcc -g program_name.c -o program_name

To use valgrind:
valgrind --leak-check=full ./program_name


--

To use malloc:
#include <stdlib.h>
- malloc( sizeof (data_type_name) ) 
- free (pointer_variable_name )



****************************
Chapter 7
****************************


Variadic functions

stdarg.h is a header in the C standard library of the C programming language that allows functions to accept an indefinite number of arguments.

It provides facilities for stepping through a list of function arguments of unknown number and type. C++ provides this functionality in the header cstdarg.

Variadic functions are functions which may take a variable number of arguments and are declared with an ellipsis in place of the last parameter. An example of such a function is printf.

A typical declaration is
int check(int a, double b, ...);

Variadic functions must have at least one named parameter, so, for instance,
char *wrong(...);

is not allowed in C. (In C++, such a declaration is permitted, but not very useful.) In C, a comma must precede the ellipsis; in C++, it is optional.

To access the unnamed arguments, one must declare a variable of type va_list in the variadic function. The macro va_start is then called with two arguments: the first is the variable declared of the type va_list, the second is the name of the last named parameter of the function.

After this, each invocation of the va_arg macro yields the next argument. The first argument to va_arg is the va_list and the second is the type of the next argument passed to the function.

Finally, the va_end macro must be called on the va_list before the function returns. (It is not required to read in all the arguments.)





====
hex dump

xxd <file_name> for file hex dump

The right column in the output is the ascii translation of the numbers
==

Microprocessor vs microcontroller
	
A microprocessor generally does not have Ram, ROM and IO pins. It usually uses its pins as a bus to interface to peripherals such as RAM, ROM, Serial ports, Digital and Analog IO. It is expandable at the board level due to this.

A microcontroller is 'all in one', the processor, ram, IO all on the one chip, as such you cannot (say) increase the amount of RAM available or the number of IO ports. The controlling bus is internal and not available to the board designer.

This means that a microprocessor is generally capable of being built into bigger general purpose applications than a microcontroller. The microcontroller is usually used for more dedicated applications.

All of this is very general statements, there are chips available that blur the boundaries.


==


Arduino

An Arduino is a PCB containing an Atmel AVR microcontroller and usually providing a set of connectors in a standard pattern. The microcontroller is typically preprogrammed with a "bootloader" program that allows a program (called a "sketch") to be loaded into the microcontroller over a TTY serial connection (or virtual serial over USB connection) from a PC.
Microprocessor

A microprocessor is an IC that contains only a central processing unit (CPU). The IC does not contain RAM, ROM or other peripherals. The IC may contain cache memory but it is not designed to be usable without any external memory.

Microprocessors cannot store programs internally and therefore typically load software when powered on, this usually involves a complex multi-stage "boot" process where "firmware" is loaded from external ROM and eventually an operating system is loaded from other storage media (e.g. hard disk).

It is typically found in a personal computer.
Microcontroller

A microcontroller is an IC that contains a CPU as well as some amount or RAM, ROM and other peripherals. Microcontrollers can function without external memory or storage.

Normally, microcontrollers are either programmed before being soldered to a PCB or are programmable using In-System-Programming (ISP or ICSP) connectors via a special "programmer" device attached to a personal computer.

Typical microcontrollers are much simpler and slower than typical microprocessors but I believe the distinction is mostly one of scale and application.

It is found, for example, in simple appliances such as basic washing machines.

==

High Address

Stack
Heap
Globals
Constants
Code (after the assembly has changed it to zeros and ones from assembly language)

Low Address


==================

Overloading vs. overriding  

Overriding of functions occurs when one class is inherited from another class. Overloading can occur without inheritance.

Overloaded functions must differ in function signature ie either number of parameters or type of parameters should differ. In overriding, function signatures must be same.

Overridden functions are in different scopes; whereas overloaded functions are in same scope.

Overriding is needed when derived class function has to do some added or different job than the base class function.

Overloading is used to have same name functions which behave differently depending upon parameters passed to them.

What is overriding?
Defining a function in the derived class with same name as in the parent class is called overriding. In C++, the base class member can be overridden by the derived.............


Explain the problem with overriding functions.
Overriding of functions occurs in Inheritance. A derived class may override a base class member function. In overriding, the function names and parameter list are same in both the functions...............


Explain the difference between overloaded functions and overridden functions.
Overloading is a static or compile-time binding and Overriding is dynamic or run-time binding.
Redefining a function in a derived class is called function overriding


=========

POSIX

POSIX an acronym for Portable Operating System Interface,is a family of standards specified by the IEEE Computer Society for maintaining compatibility between operating systems. POSIX defines the application programming interface (API), along with command line shells and utility interfaces, for software compatibility with variants of Unix and other operating systems.

==========


The math library must be linked in when building the executable. How to do this varies by environment, but in Linux/Unix, just add -lm to the command:

gcc test.c -o test -lm
The math library is named libm.so, and the -l command option assumes a lib prefix and .a or .so suffix.

=========
